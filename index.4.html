<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet">
<title>Loopover</title>

<style>
body {
    font-family: "Roboto";
    background: rgb(25, 26, 29);
    margin: 0;
    color: rgba(255, 255, 255, 0.8);
}
main {
    max-width: 480px;
    margin: 32px auto;
    padding: 0 16px;
}
h1 {
    font-size: 28px;
    margin: 0 0 24px;
}

#canvas {
    display: block;
    width: 100%;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.05);
    margin-bottom: 16px;
    image-rendering: pixelated;
}

button {
    all: unset;
    height: 32px;
    border-radius: 4px;
    padding: 4px 8px;
    font-weight: 500;
    font-size: 14px;
    cursor: pointer;
    transition: background 120ms;
}
button:hover { background: rgba(255, 255, 255, 0.05); }
button:active, button.active { background: rgba(255, 255, 255, 0.1); }
</style>

<main style="position: relative;">
    <div style="display: flex; align-items: flex-end;">
        <div style="flex-grow: 1; margin-bottom: 12px;" class="info">
            <h1 style="flex-grow: 1;">Loopover</h1>
            <div style="font-size: 20px; font-weight: bold; margin-bottom: 4px;">0:0.000</div>
            <div style="font-size: 14px;">0 moves (0.0 mps)</div>
        </div>
        <div style="display: flex;">
            <button id="resetButton" style="margin: 0 0 12px;">RESET</button>
            <button id="scrambleButton" style="margin: 0 0 12px;">SCRAMBLE</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>
    <div id="buttonGroup" style="display: flex; flex-wrap: wrap;">
    </div>
    <button id="spacing" class="button">Spacing: 0</button>
</main>

<script>(() => {
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById("canvas")
const ctx = canvas.getContext("2d")

const tilesCanvas = document.createElement("canvas")
const tilesCtx = tilesCanvas.getContext("2d")

const dpr = devicePixelRatio || 1
let cols = 5, rows = 5, aspectRatio = cols / rows
let width = 0, height = 0
let size = 0, roundedSize
let gap = 0

/** @type {number[][]} */
let state = null
/** @type {'row' | 'col'} */
let lockedDirection = null
/** @type {Map<number, { startX: number, startY: number, x: number, y: number}>} */
let touches = new Map
/** @type {ClientRect} */
let rect = null

const onMove = (touch) => {
    const startCol = Math.floor((touch.startX - rect.left) / size * dpr)
    const startRow = Math.floor((touch.startY - rect.top) / size * dpr)
    const col = Math.floor((touch.x - rect.left) / size * dpr)
    const row = Math.floor((touch.y - rect.top) / size * dpr)
    if (Math.abs(startCol - col) >= 1 || Math.abs(startRow - row) >= 1) {
        moveRow((startRow + rows) % rows, col - startCol)
        moveCol((startCol + cols) % cols, row - startRow)
        touch.startX = touch.x, touch.startY = touch.y
        draw()
    }
}

canvas.addEventListener("mousedown", e => {
    rect = canvas.getBoundingClientRect()
    touches.set(-1, { startX: e.clientX, startY: e.clientY, x: 0, y: 0 })
})
addEventListener("mousemove", e => {
    if (touches.has(-1)) {
        const touch = touches.get(-1)
        touch.x = e.clientX, touch.y = e.clientY
        onMove(touch)
    }
})
addEventListener("mouseup", e => touches.delete(-1))

canvas.addEventListener("touchstart", e => {
    e.preventDefault()
    rect = canvas.getBoundingClientRect()
    for (let item of e.changedTouches) {
        touches.set(item.identifier, {
            startX: item.clientX, startY: item.clientY, x: 0, y: 0
        })
    }
})
addEventListener("touchmove", e => {
    for (let item of e.changedTouches) {
        const touch = touches.get(item.identifier)
        touch.x = item.clientX, touch.y = item.clientY
        onMove(touch)
    }
})
addEventListener("touchend", e => {
    for (let item of e.changedTouches) {
        touches.delete(item.identifier)
    }
})

const resetState = () => {
    state = new Array(rows).fill(null)
    .map((_, row) => new Array(cols).fill(null)
    .map((_, col) => row * cols + col))
}

const moveRow = (i, n) => {
    const row = state[i]
    state[i] = row.map((cell, i) => row[(i + cols * 2 - n) % cols])
}

const moveCol = (i, n) => {
    const col = new Array(rows).fill(null).map((_, j) => state[j][i])
    for (let j = 0; j < rows; j++) state[j][i] = col[(j + rows * 2 - n) % rows]
}

async function scramble(moves) {
    for (let i = 0; i < moves; i++) {
        if (Math.random() > 0.5) moveRow(Math.floor(Math.random() * rows), Math.floor(Math.random() * cols))
        else moveCol(Math.floor(Math.random() * cols), Math.floor(Math.random() * rows))
        draw()
        await new Promise(res => setTimeout(res, 5))
    }
}

const updateGameSize = (newCols, newRows) => {
    cols = newCols, rows = newRows,
    aspectRatio = cols / rows
    resetState()
    updateCanvasSize(canvas.getBoundingClientRect())
}

const updateCanvasSize = rect => {
    width = Math.round(rect.right * dpr) - Math.round(rect.left * dpr)
    height = Math.round(width / aspectRatio)
    size = Math.ceil((width - gap * 2) / cols)
    tilesCanvas.width = Math.ceil(size) * rows * cols, tilesCanvas.height = Math.ceil(size)
    drawTilesCanvas()
    canvas.width = width, canvas.height = height
    draw()
}


const drawTilesCanvas = () => {
    tilesCtx.clearRect(0, 0, size*cols*rows, size)
    const padd = gap / 2 + gap;
    tilesCtx.font = `${size*0.45}px monospace`
    tilesCtx.textBaseline = "middle"
    tilesCtx.textAlign = "center"
    tilesCtx.lineJoin = "round"
    tilesCtx.lineWidth = gap
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const i = row * cols + col
            const xOffset = Math.ceil(size)*i
            const cx = (col + .2) / (cols - .8), cy = (row + .2) / (rows - .8)
            tilesCtx.fillStyle = `rgb(${[cx * 230, cy * 140 + (1 - cx) * 60 + 40, (1 - cx) * 210].join()})`
            tilesCtx.strokeStyle = tilesCtx.fillStyle
            if (padd == 0) {
                tilesCtx.fillRect(xOffset|0, padd, size-padd*2+1, size-padd*2+1)
            } else {
                tilesCtx.fillRect(xOffset+padd, padd, size-padd*2+10, size-padd*2+1)
                tilesCtx.strokeRect(i*size+padd, padd, size-padd*2, size-padd*2)
            }
            tilesCtx.fillStyle = "#fff"
            tilesCtx.fillText(i+1, xOffset+size/2, size/2+2)
        }
    }
}

const drawTile = (x, y, i) => {
    ctx.drawImage(tilesCanvas,
        i*size, 0, size, size, x|0, y|0, size, size
    )
}

const draw = () => {
    ctx.clearRect(0, 0, width, height)

    const moveDir = "row"
    for (let j = 0; j < (moveDir == "col" ? cols : rows); j++) {
        // let moveAmount = moveState.direction != null ? moveState.moving.get(j) || 0 : 0
        // let isMoving = moveAmount != null
        let moveAmount = 0

        for (let k = Math.floor(-moveAmount); k < (moveDir == "col" ? rows : cols) - Math.floor(moveAmount); k++) {
            let [x, y] = [k, j]
            let px = k + moveAmount
            let py = j
            if (moveDir == "col") {
                [px, py] = [py, px];
                [x, y] = [y, x];
            }
            drawTile(px * (width-gap*2)/cols + gap, py * (height-gap*2)/rows + gap, state[(y + rows*2) % rows][(x + cols*2) % cols])
        }
    }
}

new ResizeObserver(l => l.forEach(x => updateCanvasSize(x.contentRect)))
.observe(canvas)

resetState()

document.getElementById("resetButton").onclick = e => {
    resetState()
    draw()
}
document.getElementById("scrambleButton").onclick = e => scramble(80)
let spacingButton = document.getElementById("spacing")
spacingButton.onclick = e => {
    spacing += 2
    if (spacing > 6) spacing = 0
    spacingButton.innerText = `Spacing: ${spacing}`
    updateCanvasSize(canvas.getBoundingClientRect())
    draw()
}

let gameSizes = [[2,2],[3,3],[4,4],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]
let active = gameSizes[0]
let buttonGroup = document.getElementById("buttonGroup")
// updateGameSize(active)

for (let gameSize of gameSizes) {
    let button = document.createElement("button")
    button.innerText = `${gameSize[0]}x${gameSize[1]}`
    if (active == gameSize) button.classList.add("active")
    button.onclick = e => {
        updateGameSize(gameSize[0], gameSize[1])
    }
    buttonGroup.appendChild(button)
}

})()</script>