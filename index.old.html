<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="theme-color" content="#222325">
<link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700" rel="stylesheet">
<title>Loopover</title>

<style>
body {
    font-family: "Roboto";
    background: rgb(25, 26, 29);
    margin: 0;
    color: rgba(255, 255, 255, 0.8);
}
main {
    max-width: 480px;
    margin: 24px auto;
    padding: 0 16px;
}
h1 {
    font-size: 28px;
    margin: 0 0 16px;
}

#canvas {
    display: block;
    width: 100%;
    border-radius: 4px;
    background: rgba(255, 255, 255, 0.05);
    margin-bottom: 16px;
}

button {
    all: unset;
    height: 32px;
    border-radius: 4px;
    padding: 4px 8px;
    font-weight: 500;
    font-size: 14px;
    cursor: pointer;
    transition: background 120ms;
}
button:hover { background: rgba(255, 255, 255, 0.05); }
button:active, button.active { background: rgba(255, 255, 255, 0.1); }
</style>

<main style="position: relative;">
    <h1>Loopover</h1>
    <div style="display: flex; align-items: flex-end; height: 72px;">
        <div style="flex-grow: 1; margin-bottom: 12px;" class="info">
            <div id="timer" style="font-size: 20px; font-weight: bold;">0:0.000</div>
            <div id="info" style="font-size: 14px; margin-top: 6px;">32 moves (2.1 mps)</div>
            <!-- <div style="font-size: 14px; margin-bottom: 8px;">Game starts on first move</div> -->
        </div>
        <div style="display: flex; margin-bottom: 8px;">
            <button id="resetButton">RESET</button>
            <button id="scrambleButton">SCRAMBLE</button>
        </div>
    </div>
    <canvas id="canvas"></canvas>
    <div id="buttonGroup" style="display: flex; flex-wrap: wrap;">
    </div>
    <button id="spacing" class="button">Spacing: 0</button>
</main>

<script>(() => {
/** @type {HTMLCanvasElement} */
const canvas = document.getElementById("canvas")
const ctx = canvas.getContext("2d")

const tilesCanvas = document.createElement("canvas")
const tilesCtx = tilesCanvas.getContext("2d")
// document.querySelector("main").appendChild(tilesCanvas)

const dpr = devicePixelRatio || 1
let cols = 5, rows = 5, aspectRatio = cols / rows
let width = 0, height = 0
let size = 0, roundedSize
let gap = 0
let useLetters = true
let gameStarted = false
let gameReady = false
let startTime = 0
let moves = 0

/** @type {number[][]} */
let state = null
/** @type {'row' | 'col'} */
let lockedDirection = null
/** @type {Map<number, { startX: number, startY: number, x: number, y: number}>} */
let touches = new Map
/** @type {Map<number, number>} */
let moveAmounts = new Map
/** @type {ClientRect} */
let rect = null

const checkIfSolved = () => {
    for (let [r, row] of state.entries()) {
        for (let [c, col] of row.entries()) {
            if (col != r * cols + c) return false
        }
    }
    return true
}

const formatTime = ms => {
    return `${ms/1000/60|0}:${((ms/1000)%60|0).toString().padStart(2, 0)}:${(ms%1000).toString().padStart(3, 0)}`
}

const resetState = () => {
    state = new Array(rows).fill(null)
    .map((_, row) => new Array(cols).fill(null)
    .map((_, col) => row * cols + col))
    gameReady = false
    gameStarted = false
    timerDiv.innerText = formatTime(0)
    infoDiv.innerText = "Tap scramble to start a new game"
}

const move = () => {
    const isSolved = checkIfSolved()
    if (gameReady && !gameStarted) {
        gameStarted = true
        gameReady = false
        moves = 0
        startTime = Date.now()
        let interval = setInterval(() => {
            if (!gameStarted) return clearInterval(interval)
            timerDiv.innerText = formatTime(Date.now() - startTime)
        }, 10)
    }
    if (gameStarted) {
        moves += 1
        infoDiv.innerText = `${moves} moves`
    }
    if (gameStarted && isSolved) {
        timerDiv.innerText = formatTime(Date.now() - startTime)
        infoDiv.innerText = `Game finished in ${moves} moves`
        gameStarted = false
    }
}

const moveRow = (i, n) => {
    const row = state[i]
    state[i] = row.map((cell, i) => row[(i + cols * 2 - n) % cols])
}

const moveCol = (i, n) => {
    const col = new Array(rows).fill(null).map((_, j) => state[j][i])
    for (let j = 0; j < rows; j++) state[j][i] = col[(j + rows * 2 - n) % rows]
}

async function scramble(moves) {
    infoDiv.innerText = "Game starts on first move"
    for (let i = 0; i < moves; i++) {
        if (Math.random() > 0.5) moveRow(Math.floor(Math.random() * rows), Math.floor(Math.random() * cols))
        else moveCol(Math.floor(Math.random() * cols), Math.floor(Math.random() * rows))
        await new Promise(res => setTimeout(res, 5))
        draw()
    }
    if (checkIfSolved()) await scramble(moves)
    gameReady = true
}

const updateGameSize = (newCols, newRows) => {
    cols = newCols, rows = newRows,
    aspectRatio = cols / rows
    resetState()
    updateCanvasSize(canvas.getBoundingClientRect())
}

const updateCanvasSize = rect => {
    width = Math.round(rect.right * dpr) - Math.round(rect.left * dpr)
    height = Math.round(width / aspectRatio)
    size = Math.ceil((width - gap*dpr*2) / cols)
    tilesCanvas.width = Math.ceil(size) * rows * cols, tilesCanvas.height = Math.ceil(size)
    drawTilesCanvas()
    canvas.width = width, canvas.height = height
    draw()
}

const drawTile = (x, y, i) => ctx.drawImage(tilesCanvas,
    i*size, 0, size, size, x, y, size, size
)

const draw = () => {
    ctx.clearRect(0, 0, width, height)
    const moveDir = lockedDirection == "col" ? "row" : "col"
    for (let j = 0; j < (moveDir == "col" ? cols : rows); j++) {
        let moveAmount = lockedDirection != null ? moveAmounts.get(j) || 0 : 0
        for (let k = Math.floor(-moveAmount); k < (moveDir == "col" ? rows : cols) - Math.floor(moveAmount); k++) {
            let [x, y] = [k, j]
            let px = k + moveAmount, py = j
            if (moveDir == "col") {
                [px, py] = [py, px]; [x, y] = [y, x];
            }
            drawTile(px * (width-gap*dpr*2)/cols + gap * dpr, py * (height-gap*dpr*2)/rows + gap * dpr, state[(y + rows*2) % rows][(x + cols*2) % cols])
        }
    }
}

const drawTilesCanvas = () => {
    tilesCtx.clearRect(0, 0, size*cols*rows, size)
    const padd = (gap / 2 + gap) * dpr;
    tilesCtx.font = `${size*0.4}px monospace`
    tilesCtx.textBaseline = "middle", tilesCtx.textAlign = "center"
    tilesCtx.lineJoin = "round", tilesCtx.lineWidth = gap * dpr
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const i = row * cols + col, xOffset = Math.ceil(size)*i
            const text = useLetters && cols * rows <= 26 ? String.fromCharCode(i+65) : (i + 1).toString()
            const cx = (col + .2) / (cols - .8), cy = (row + .2) / (rows - .8)
            tilesCtx.fillStyle = `rgb(${[cx * 230, cy * 140 + (1 - cx) * 60 + 40, (1 - cx) * 210].join()})`
            tilesCtx.strokeStyle = tilesCtx.fillStyle
            tilesCtx.fillRect(xOffset+padd, padd, size-padd*2, size-padd*2)
            if (padd != 0) tilesCtx.strokeRect(xOffset+padd, padd, size-padd*2, size-padd*2)
            tilesCtx.fillStyle = "#fff"
            tilesCtx.fillText(text, xOffset+size/2, size/2+2)
        }
    }
}

function setupEventListeners() {
    const onStart = touch => {
    }
    const onMove = touch => {
        const dx = touch.x - touch.startX
        const dy = touch.y - touch.startY
        if (lockedDirection || Math.hypot(dx, dy) > 10) {
            if (!lockedDirection) {
                lockedDirection = Math.abs(dx) > Math.abs(dy) ? "col" : "row"
            }
            let index = lockedDirection == "row" ? Math.floor((touch.startX - rect.left) / size * dpr) : Math.floor((touch.startY - rect.top) / size * dpr)
            touch.index = index
            moveAmounts.set(touch.index, lockedDirection == "col" ? dx / rect.width * cols : dy / rect.height * rows)
            draw()
        }
    }
    const onEnd = touch => {
        const moveAmount = moveAmounts.get(touch.index)
        if (lockedDirection == 'col') {
            moveRow(touch.index, Math.round(moveAmount))
        } else {
            moveCol(touch.index, Math.round(moveAmount))
        }
        moveAmounts.delete(touch.index)
        lockedDirection = null
        draw()
        move()
    }

    if (window.ResizeObserver) {
        new ResizeObserver(l => l.forEach(x => updateCanvasSize(x.contentRect)))
        .observe(canvas)
    }
    updateCanvasSize(canvas.getBoundingClientRect())
    canvas.addEventListener("mousedown", e => {
        e.preventDefault()
        rect = canvas.getBoundingClientRect()
        touches.set(-1, { startX: e.clientX, startY: e.clientY, x: 0, y: 0 })
        onStart(touches.get(-1))
    })
    addEventListener("mousemove", e => {
        if (!touches.has(-1)) return
        const touch = touches.get(-1)
        touch.x = e.clientX, touch.y = e.clientY
        onMove(touch)
    })
    addEventListener("mouseup", e => {
        if (touches.has(-1)) onEnd(touches.get(-1))
        touches.delete(-1)
    })
    canvas.addEventListener("touchstart", e => {
        e.preventDefault()
        rect = canvas.getBoundingClientRect()
        for (let item of e.changedTouches) {
            touches.set(item.identifier, {
                startX: item.clientX, startY: item.clientY, x: 0, y: 0
            })
            onStart(touches.get(item.identifier))
        }
    })
    addEventListener("touchmove", e => {
        for (let item of e.changedTouches) {
            if (!touches.has(item.identifier)) continue
            const touch = touches.get(item.identifier)
            touch.x = item.clientX, touch.y = item.clientY
            onMove(touch)
        }
    })
    addEventListener("touchend", e => {
        for (let item of e.changedTouches) {
            onEnd(touches.get(item.identifier))
            touches.delete(item.identifier)
        }
    })
}

function setup() {
    resetState()
    setupEventListeners()
}

const timerDiv = document.getElementById("timer")
const infoDiv = document.getElementById("info")

document.getElementById("resetButton").onclick = e => {
    resetState()
    draw()
}
document.getElementById("scrambleButton").onclick = e => {
    resetState()
    scramble(cols*rows*2+4)
}
let spacingButton = document.getElementById("spacing")
spacingButton.onclick = e => {
    gap += 2
    if (gap > 8) gap = 0
    spacingButton.innerText = `Spacing: ${gap}`
    updateCanvasSize(canvas.getBoundingClientRect())
    draw()
}
spacingButton.innerText = `Spacing: ${gap}`

let gameSizes = [[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8],[9,9],[10,10]]
let active = gameSizes[3]
let buttonGroup = document.getElementById("buttonGroup")
/** @type {HTMLButtonElement[]} */
let buttons = []

for (let [i, gameSize] of gameSizes.entries()) {
    let button = document.createElement("button")
    button.innerText = `${gameSize[0]}x${gameSize[1]}`
    if (active == gameSize) button.classList.add("active")
    button.onclick = e => {
        updateGameSize(gameSize[0], gameSize[1])
        for (let [j, button] of buttons.entries()) {
            button.classList.toggle("active", j == i)
        }
    }
    buttons.push(button)
    buttonGroup.appendChild(button)
}

setup()
updateGameSize(active[0], active[1])

})()</script>