<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="manifest" href="manifest.json">
<link rel="icon" href="icon.png" type="image/png">

<link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
<script src="ResizeObserver.js"></script>

<title>Loopover</title>

<style>
  :root {
    --background: #f2f0ed;
    --color: rgba(10, 5, 0, 0.75);
    --shade: rgba(0, 0, 0, 0.12);
    --shade-light: rgba(0, 0, 0, 0.05);
  }

  :root.dark {
    --background: #212129;
    --color: rgba(255, 255, 255, 0.8);
    --shade: rgba(255, 255, 255, 0.1);
    --shade-light: rgba(255, 255, 255, 0.05);
  }

  body {
    margin: 0;
    font-family: "Roboto";
    color: var(--color);
    background: var(--background);
  }

  main {
    max-width: 480px;
    margin: 32px auto 64px;
    padding: 0 24px;
    transition: max-width 200ms, padding 200ms;
  }

  main.big {
    max-width: 560px;
    padding: 0 16px;
  }

  @media (min-width: 560px) {
    main {
      padding: 0 32px;
    }
  }

  h1 {
    font-size: 32px;
    font-weight: 900;
    height: 32px;
    margin: 0 0 24px;
  }

  h3 {
    margin: 24px 0 16px;
  }

  hr {
    all: unset;
    display: block;
    height: 1px;
    margin: 24px 0;
    background: var(--shade);
  }

  a {
    color: inherit;
    font-weight: bold;
  }

  p {
    line-height: 1.5;
  }

  #canvas {
    display: block;
    width: 100%;
    border-radius: 6px;
    background: var(--shade);
    filter: brightness(1.06);
  }

  :root.dark #canvas {
    filter: none;
  }

  button {
    all: unset;
    display: block;
    height: 36px;
    padding: 0 8px;
    min-width: 32px;
    font-size: 14px;
    text-align: center;
    font-weight: 500;
    border-radius: 4px;
    cursor: pointer;
    text-transform: uppercase;
    user-select: none;
    transition: background 150ms;
  }

  button:hover {
    background: var(--shade-light);
  }

  button:active,
  button.active {
    background: var(--shade);
  }

  #timer {
    font-size: 20px;
    font-weight: bold;
  }

  #info {
    font-size: 14px;
    margin-top: 6px;
    opacity: 0.7;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }

  td,
  th {
    border-right: 1px solid var(--shade);
    padding: 8px;
  }

  td:last-child,
  th:last-child {
    border-right: none;
  }

  th {
    border-bottom: 1px solid var(--shade);
  }

  td {
    text-align: right;
  }

  ul {
    margin: 0 0 24px;
    padding-left: 16px;
  }

  .card {
    background: var(--shade-light);
    border-radius: 4px;
    padding: 8px;
    box-sizing: border-box;
    width: calc(25% - 8px);
    font-size: 14px;
    margin: 0 4px 8px;
    min-width: 120px;
    flex-grow: 1;
  }

  .card h4 {
    margin: 0 0 4px;
    line-height: 1;
    font-size: 16px;
  }

  [v-cloak] {
    display: none;
  }
</style>

<main id="app" :class="{big: gameSize > 7}" v-cloak>
  <h1>Loopover</h1>
  
  <div style="display: flex; align-items: flex-end; height: 72px;">
    <div style="flex-grow: 1; margin-bottom: 16px;">
      <div id="timer">{{ formatTime(time) }}</div>
      <div id="info">
        <template v-if="isScrambled">
          The timer starts with the next move
        </template>
        <template v-else-if="gameStarted || moves > 0">
          {{ moves }} moves
        </template>
        <template v-else>
          Tap scramble to start a new game
        </template>
      </div>
    </div>

    <div style="margin: 0 0 12px; display: flex;">
      <button @click="reset" v-if="!isSolved">Reset</button>
      <button @click="scramble">Scramble</button>
    </div>
  </div>
  
  <canvas id="canvas" width="480" height="480"></canvas>
  
  <div style="margin-top: 24px; display: flex; flex-wrap: wrap; justify-content: center">
    <button v-for="item in gameSizes" :class="{active: item == gameSize}" @click="gameSize = item">
      {{ eventName(item) }}
    </button>
  </div>
  
  <hr>

  <button @click="dark = !dark">{{ dark ? "Use light theme" : "Use dark theme" }}</button>
  <button @click="useSpacing = !useSpacing">{{ useSpacing ? "Remove space between tiles" : "Add space between tiles" }}</button>
  <button @click="fastMode = !fastMode">{{ fastMode ? "Disable fast mode" : "Enable fast mode" }}</button>
  <button @click="tileMode = tileModes[tileMode%tileModes.length][0]">Tile mode: {{ tileModes[tileMode-1][1] }}</button>
  
  <hr>
  
  <h3>Last solves</h3>
  
  <ul style="list-style-type: none;">
    <li style="margin-bottom: 4px;" v-for="i in 5">
      {{ currentStats.solves[currentStats.solves.length - i] ? formatTime(currentStats.solves[currentStats.solves.length - i]) : "-" }}
    </li>
  </ul>

  <hr>
  
  <h3>Stats for {{ eventName(gameSize) }}</h3>

  <div style="display: flex; flex-wrap: wrap; margin: 0 -8px 16px;">
    <div class="card">
      <h4>Best time</h4>
      {{ formatTime(currentStats.bestTime) }}
    </div>
    <div class="card">
      <h4>Worst time</h4>
      {{ formatTime(currentStats.worstTime) }}
    </div>
    <div class="card">
      <h4>Fewest moves</h4>
      {{ currentStats.fewestMoves || "-" }}
    </div>
    <div class="card">
      <h4>Total solves</h4>
      {{ currentStats.solves.length }}
    </div>
  </div>

  <table>
    <tr>
      <th style="width: 33.3%;"></th>
      <th>Best</th>
      <th>Current</th>
    </tr>
    <tr v-for="i in [3, 5, 12, 50]">
      <td>Average of {{i}}</td>
      <td>{{ bestAverages[i] }}</td>
      <td>{{ averages[i] }}</td>
    </tr>
  </table>

  <button @click="resetStats(gameSize)" style="margin-top: 24px;">
    Reset stats for {{ eventName(gameSize) }} event
  </button>
  
  <hr>

  <p>
    Created by <a target="_blank" href="https://twitter.com/janispritzkau"> Janis Pritzkau</a>.
    Remake of carykh's <a target="_blank" href="https://openprocessing.org/sketch/580366">loopover</a>.
  </p>
</main>

<script>
  (() => {
    if (navigator.serviceWorker) {
      navigator.serviceWorker.register("serviceWorker.js").catch(err => {
        console.error("Failed to register service worker")
      })
    }

    const checkIfSolved = state => {
      for (let [rowIndex, row] of state.entries()) {
        for (let [col, tile] of row.entries()) {
          if (tile != rowIndex * row.length + col) return false
        }
      }
      return true
    }

    const debounce = (fn, time) => {
      let timeout
      return function () {
        const functionCall = () => fn.apply(this, arguments)
        clearTimeout(timeout)
        timeout = setTimeout(functionCall, time)
      }
    }

    const mapToObject = map => {
      let obj = {}; for (let [k, v] of map) obj[k] = v; return obj
    }
    const objectToMap = obj => new Map(Object.keys(obj).map(k => [Number(k), obj[k]]))

    const TileMode = { letters: 1, numbers: 2, coords: 3 }

    const app = new Vue({
      el: "#app",
      data: {
        dark: false,
        tileModes: [
          [TileMode.letters, "Letters"],
          [TileMode.numbers, "Numbers"],
          [TileMode.coords, "Coordinates"]
        ],
        tileMode: TileMode.letters,
        useSpacing: false,
        isSolved: true,
        isScrambled: false,
        gameStarted: false,
        time: 0,
        moves: 0,
        fastMode: true,
        gameSizes: [2, 3, 4, 5, 6, 7, 8, 9, 10],
        gameSize: 5,
        stats: new Map(),
        currentStats: { solves: [] },
        bestAverages: {},
        averages: {}
      },
      methods: {
        eventName: gameSize => `${gameSize}Ã—${gameSize}`,
        formatTime(ms, noPad = true) {
          if (ms == null) return "-"
          const s = ms / 1000
          const min = s / 60 | 0, sec = s % 60 | 0, mil = (ms % 1000) | 0 
          return `${min}:${sec.toString().padStart(2, 0)}:${mil.toString().padStart(3, 0)}`
        },
        getBestAverageTime(n) {
          const solves = this.currentStats.solves
          if (solves.length < n) return '-'
          let bestTime = null
          for (let i = 0; i <= solves.length - n; i++) {
            const solves = this.currentStats.solves.slice(i, i + n).sort((a, b) => a - b)
            let time = n == 3 ? solves[1] : solves.slice(1, n - 1).reduce((acc, x) => acc + x / (n - 2), 0)
            if (bestTime == null || time < bestTime) bestTime = time
          }
          return this.formatTime(bestTime)
        },
        getAverageTime(n) {
          if (this.currentStats.solves.length < n) return '-'
          const solves = this.currentStats.solves.slice(-n).sort((a, b) => a - b)
          return this.formatTime(
            n == 3 ? solves[1] : solves.slice(1, n - 1).reduce((acc, x) => acc + x / (n - 2), 0)
          )
        },
        updateAverages() {
          [3, 5, 12].forEach(i => {
            this.averages[i] = this.getAverageTime(i)
            this.bestAverages[i] = this.getBestAverageTime(i)
          })
        },
        resetStats(gameSize) {
          if (confirm(`Are you sure you want to reset your stats for ${this.eventName(gameSize)}?`)) {
            this.stats.delete(gameSize)
            this.currentStats = { solves: [] }
          }
        },
        reset() {
          this.resetGameState()
          draw()
        },
        resetGameState() {
          this.game = createNewGameState(cols, rows)
          state = this.game
          this.isSolved = true
          this.isScrambled = false
          this.gameStarted = false
          this.time = 0
          this.moves = 0
        },
        async scramble() {
          this.resetGameState()
          this.isScrambled = true
          this.isSolved = false
          scramble(cols * rows + 8)
          draw()
        },
        onSolved() {
          this.gameStarted = false
          this.isSolved = true
          clearInterval(this._timerInterval)
          this.time = Date.now() - this._startTime

          this.currentStats.solves.push(this.time)
          if (this.currentStats.fewestMoves == null || this.moves < this.currentStats.fewestMoves) this.currentStats.fewestMoves = this.moves
          if (this.currentStats.bestTime == null || this.time < this.currentStats.bestTime) this.currentStats.bestTime = this.time
          if (this.currentStats.worstTime == null || this.time > this.currentStats.worstTime) this.currentStats.worstTime = this.time
          this.updateAverages()
        },
        startGame() {
          this.gameStarted = true
          this.isScrambled = false
          this._timerInterval = setInterval(() => {
            this.time = Date.now() - this._startTime
          }, 63)
          this._startTime = Date.now()
        },
        onMove(n) {
          this.isSolved = checkIfSolved(state)
          if (!this.gameStarted && this.isScrambled) this.startGame()
          if (this.gameStarted) this.moves += n
          if (this.gameStarted && this.isSolved) this.onSolved()
        },
        _saveState: debounce(function () {
          localStorage.setItem("loopover", JSON.stringify({
            dark: this.dark,
            tileMode: this.tileMode,
            fastMode: this.fastMode,
            useSpacing: this.useSpacing,
            gameSize: this.gameSize,
            stats: mapToObject(this.stats)
          }))
        }, 500),
        saveState() {
          if (this.isLoaded) this._saveState()
        },
        loadState() {
          const data = localStorage.getItem("loopover")
          if (!data) return
          let { stats, ...state } = JSON.parse(data)
          for (let key in state) this.$data[key] = state[key]
          if (stats) this.stats = objectToMap(stats)
        }
      },
      created() {
        this.loadState()
        setTimeout(() => {
          this.isLoaded = true
          this.currentStats = this.stats.get(this.gameSize) || { solves: [] }
          this.updateAverages()
        })
      },
      watch: {
        gameStarted() {
          if (this.gameStarted == false) clearInterval(this._timerInterval)
        },
        dark: {
          immediate: true, handler(value) {
            document.documentElement.classList.toggle("dark", value)
            this.saveState()
          }
        },
        currentStats: {
          deep: true, handler() {
            let a = !this.stats.has(this.gameSize)
            if (!this.stats.has(this.gameSize) && this.currentStats.solves.length > 0)
              this.stats.set(this.gameSize, this.currentStats)
            this.saveState()
          }
        },
        gameSize() {
          this.currentStats = this.stats.get(this.gameSize) || { solves: [] }
          updateGameSize()
          this.resetGameState()
          updateCanvasSize()
          this.updateAverages()
        },
        tileMode(mode) {
          drawTilesCanvas()
          draw()
          this.saveState()
        },
        useSpacing() {
          updateCanvasSize()
          this.saveState()
        },
        fastMode() {
          this.saveState()
        }
      }
    })
    window.app = app

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")

    const tilesCanvas = document.createElement("canvas")
    const tilesCtx = tilesCanvas.getContext("2d")

    let dpr = devicePixelRatio
    let cols = app.gameSize, rows = cols, aspectRatio = cols / rows
    let width = 0, height = 0
    let gap = 0
    let size = 0

    const transitionTime = 120
    /** @type {Map<number, { startCol: number, startRow: number, col: number, row: number }>} */
    let touches = new Map
    /** @type {Map<number, { value: number, start: number, startTime: number, isAnimated: boolean }>} */
    let transitions = new Map
    let animating = false
    /** @type {boolean} */
    let moveHorizontal = null

    /** @type {number[][]} */
    let state = app.game

    const updateGameSize = () => {
      cols = app.gameSize, rows = cols
      aspectRatio = cols / rows
    }

    const updateGapSize = () => {
      gap = app.useSpacing ? Math.round(1 * dpr + (width / cols * 0.04)) : 0
    }

    const createNewGameState = (cols, rows) => new Array(rows).fill(null)
      .map((_, row) => new Array(cols).fill(null)
        .map((_, col) => row * cols + col))

    const moveRow = (i, n) => {
      const row = state[i]
      state[i] = row.map((cell, i) => row[(i + cols * 16 - n) % cols])
    }

    const moveColumn = (i, n) => {
      const col = new Array(rows).fill(null).map((_, j) => state[j][i])
      for (let j = 0; j < rows; j++) state[j][i] = col[(j + rows * 16 - n) % rows]
    }

    function scramble(moves = 50) {
      let a = false
      for (let i = 0; i < moves; i++) {
        const moveVertical = Math.random() > 0.5 ? a : Math.random()
        const index = Math.floor(Math.random() * (moveVertical ? cols : rows))
        const n = Math.ceil(Math.random() * ((moveVertical ? rows : cols) - 1))
        
        if (moveVertical) moveColumn(index, n)
        else moveRow(index, n)
        a = !moveVertical
      }
      if (checkIfSolved(state)) scramble(moves)
    }

    const updateCanvasSize = rect => {
      if (!rect) rect = canvas.getBoundingClientRect()
      width = Math.round(rect.width * dpr)
      height = Math.round(width / aspectRatio)

      updateGapSize()
      size = Math.ceil((width - gap * 2) / cols)

      const tilesCanvasW = size * cols
      const tilesCanvasH = size * rows
      
      if (tilesCanvas.width != tilesCanvasW || tilesCanvas.height != tilesCanvasH) {
        tilesCanvas.width = tilesCanvasW, tilesCanvas.height = tilesCanvasH
      }
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width, canvas.height = height
      }
      drawTilesCanvas()
      draw()
    }

    const drawTile = (x, y, i) => ctx.drawImage(tilesCanvas,
      (i % cols) * size, ((i / cols) | 0) * size, size, size, gap > 0 ? x : x | 0, gap > 0 ? y : y | 0, size, size
    )

    const draw = () => {
      if (gap > 0) ctx.clearRect(0, 0, width, height)

      for (let j = 0; j < (moveHorizontal ? rows : cols); j++) {
        const moveAmount = moveHorizontal != null ? (transitions.get(j) || {}).value || 0 : 0

        for (let k = Math.floor(-moveAmount); k < (moveHorizontal ? cols : rows) - Math.floor(moveAmount); k++) {
          let [x, y] = [k, j]
          let px = k + moveAmount, py = j

          if (!moveHorizontal) {
            [px, py] = [py, px]; [x, y] = [y, x];
          }
          drawTile(px * (width - gap * 2) / cols + gap, py * (height - gap * 2) / rows + gap, state[(y + rows * 2) % rows][(x + cols * 2) % cols])
        }
      }
    }

    const drawTilesCanvas = () => {
      tilesCtx.clearRect(0, 0, size * cols, size * rows)
      const radius = Math.min(Math.max(6 * dpr, gap * 2) | 0, 12 * dpr)
      const padd = gap == 0 ? 0 : radius / 2 + gap;
      tilesCtx.font = `${size * 0.47}px Roboto`
      tilesCtx.textBaseline = "middle", tilesCtx.textAlign = "center"
      tilesCtx.lineJoin = "round", tilesCtx.lineWidth = radius
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const i = row * cols + col
          const xOffset = size * col, yOffset = size * row
          let text = null
          switch (app.tileMode) {
            case TileMode.numbers: text = (i + 1).toString()
              break
            case TileMode.letters: text = cols * rows <= 26 ? String.fromCharCode(i + 65) : (i + 1).toString()
              break
            case TileMode.coords: text = `${row},${col}`
          }
          const cx = 1 - (col + 0.3) / (cols - .25), cy = (row + 0.3) / (rows - .25)
          tilesCtx.fillStyle = `rgb(${[cx * 233 + 20, cy * 160 + (1 - cx) * 40 + 30, (1 - cx) * 220].map(a => Math.floor(a)).join()})`
          tilesCtx.strokeStyle = tilesCtx.fillStyle
          tilesCtx.fillRect(xOffset + padd, yOffset + padd, size - padd * 2, size - padd * 2)
          if (padd != 0) tilesCtx.strokeRect(xOffset + padd, yOffset + padd, size - padd * 2, size - padd * 2)
          tilesCtx.fillStyle = "#fff"
          if (text) tilesCtx.fillText(text, xOffset + size / 2, yOffset + size / 2 + 2)
        }
      }
    }

    const onMoveStart = touch => {
      touch.startCol = Math.floor(((touch.startX - rect.left) * dpr - gap) / size)
      touch.startRow = Math.floor(((touch.startY - rect.top) * dpr - gap) / size)
    }

    const easeOut = t => t * (2 - t)

    const frame = () => {
      animating = true
      let animatedTransitions = 0 

      for (let [index, transition] of transitions.entries()) {
        if (!transition.isAnimated) continue
        else animatedTransitions += 1
        const time = (Date.now() - transition.startTime) / transitionTime
        transition.value = transition.start - transition.start * easeOut(time)

        if (time >= 1) transitions.delete(index)
      }
      draw()
      if (animatedTransitions == 0) animating = false
      else requestAnimationFrame(frame)
    }
    
    const animateMove = (isHorizontal, index, start) => {
      let isSameDirection = moveHorizontal == isHorizontal
      if (!isSameDirection) {
        moveHorizontal = isHorizontal
        transitions.clear()
      }
      if (isSameDirection && transitions.has(index)) {
        const transition = transitions.get(index)
        transition.startTime = Date.now()
        transition.start = transition.value + start
      } else {
        const transition = {
          isAnimated: true, start, value: 0, startTime: Date.now()
        }
        transitions.set(index, transition)
      }
      if (!animating) requestAnimationFrame(frame)
    }
    
    let lockedVertical = null
    
    const onMove = touch => {
      if (app.fastMode) {
        touch.col = Math.floor(((touch.x - rect.left) * dpr - gap) / size)
        touch.row = Math.floor(((touch.y - rect.top) * dpr - gap) / size)

        let moveX = touch.row - touch.startRow
        let moveY = touch.col - touch.startCol
        
        // // No off-screen draggin
        // if (touch.col > cols - 1 || touch.col < 0) moveY = 0
        // if (touch.row > rows - 1 || touch.row < 0) moveX = 0

        if (moveX) {
          const colI = Math.min(Math.max(touch.startCol, 0), cols - 1)
          moveColumn(colI, moveX)
          animateMove(false, colI, -moveX)
          touch.startRow = touch.row
        }
        
        if (moveY) {
          const rowI = Math.min(Math.max(touch.startRow, 0), rows - 1)
          moveRow(rowI, moveY)
          animateMove(true, rowI, -moveY)
          touch.startCol = touch.col
        }

        if (moveX != 0 || moveY != 0) {
          draw()
          const moves = Math.abs(moveX) + Math.abs(moveY)
          if (moves) app.onMove(moves)
        }
      } else {
        const dx = touch.x - touch.startX, dy = touch.y - touch.startY
        if (lockedVertical != null || Math.hypot(dx, dy) > 8) {
          if (lockedVertical == null) lockedVertical = Math.abs(dx) < Math.abs(dy)
          if (moveHorizontal == lockedVertical) {
            moveHorizontal = !lockedVertical
            transitions.clear()
          }
          touch.moveIndex = lockedVertical ? touch.startCol : touch.startRow
          const moveAmount = lockedVertical ? dy / rect.height * rows : dx / rect.width * cols
          transitions.set(touch.moveIndex, {value: moveAmount})
          draw()
        }
      }
    }
    const onEnd = touch => {
      if (app.fastMode || touch.moveIndex == null) return
      const moveN = Math.round(transitions.get(touch.moveIndex).value)

      if (!lockedVertical) moveRow(touch.moveIndex, moveN)
      else moveColumn(touch.moveIndex, moveN)
      
      const moveAmount = -transitions.get(touch.moveIndex).value + moveN
      transitions.delete(touch.moveIndex)
      animateMove(!lockedVertical, touch.moveIndex, -moveAmount)
      
      if (touches.size == 1) lockedVertical = null
      if (moveN != 0) app.onMove(Math.abs(moveN))
    }

    canvas.addEventListener("mousedown", e => {
      e.preventDefault()
      rect = canvas.getBoundingClientRect()
      touches.set(-1, { startX: e.clientX, startY: e.clientY, x: 0, y: 0 })
      onMoveStart(touches.get(-1))
    })
    addEventListener("mousemove", e => {
      if (!touches.has(-1)) return
      const touch = touches.get(-1)
      touch.x = e.clientX, touch.y = e.clientY
      onMove(touch)
    })
    addEventListener("mouseup", e => (touches.has(-1) && onEnd(touches.get(-1)), touches.delete(-1)))

    canvas.addEventListener("touchstart", e => {
      e.preventDefault()
      rect = canvas.getBoundingClientRect()
      for (let item of e.changedTouches) {
        touches.set(item.identifier, {
          startX: item.clientX, startY: item.clientY, x: 0, y: 0
        })
        onMoveStart(touches.get(item.identifier))
      }
    })
    addEventListener("touchmove", e => {
      for (let item of e.changedTouches) {
        if (!touches.has(item.identifier)) continue
        const touch = touches.get(item.identifier)
        touch.x = item.clientX, touch.y = item.clientY
        onMove(touch)
      }
    })
    addEventListener("touchend", e => {
      for (let item of e.changedTouches) touches.has(item.identifier) && onEnd(touches.get(item.identifier)), touches.delete(item.identifier)
    })

    const _updateSize = debounce(updateCanvasSize, 25)
    let lastRect
    new ResizeObserver(l => l.forEach(({ contentRect: rect }) => {
      if (lastRect && lastRect.width == rect.width) return
      _updateSize(rect); lastRect = rect
    })).observe(canvas)

    app.game = createNewGameState(cols, rows)
    state = app.game
  })()
</script>
