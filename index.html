<!DOCTYPE html>
<meta name="theme-color" content="#222325">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="icon" href="icon.png" type="image/png">

<link href="https://fonts.googleapis.com/css?family=Roboto:400,500,700,900" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

<title>Loopover</title>

<style>
  :root {
    --background: #f2f0ed;
    --color: rgba(10, 5, 0, 0.75);
    --shade: rgba(0, 0, 0, 0.12);
    --shade-light: rgba(0, 0, 0, 0.05);
  }

  :root.dark {
    --background: #212129;
    --color: rgba(255, 255, 255, 0.8);
    --shade: rgba(255, 255, 255, 0.1);
    --shade-light: rgba(255, 255, 255, 0.05);
  }

  body {
    margin: 0;
    font-family: "Roboto";
    color: var(--color);
    background: var(--background);
  }

  main {
    max-width: 480px;
    margin: 32px auto 64px;
    padding: 0 24px;
    transition: max-width 200ms, padding 200ms;
  }

  main.big {
    max-width: 560px;
    padding: 0 16px;
  }

  @media (min-width: 560px) {
    main {
      padding: 0 32px;
    }
  }

  h1 {
    font-size: 32px;
    font-weight: 900;
    height: 32px;
    margin: 0 0 24px;
  }

  h3 {
    margin: 24px 0 16px;
  }

  hr {
    all: unset;
    display: block;
    height: 1px;
    margin: 24px 0;
    background: var(--shade);
  }

  a {
    color: inherit;
    font-weight: bold;
  }

  p {
    line-height: 1.5;
  }

  #canvas {
    display: block;
    width: 100%;
    border-radius: 6px;
    background: var(--shade);
    filter: brightness(1.06);
  }

  :root.dark #canvas {
    filter: none;
  }

  button {
    all: unset;
    display: block;
    height: 36px;
    padding: 0 8px;
    min-width: 32px;
    font-size: 14px;
    text-align: center;
    font-weight: 500;
    border-radius: 4px;
    cursor: pointer;
    user-select: none;
    transition: background 150ms;
  }

  button:hover {
    background: var(--shade-light);
  }

  button:active,
  button.active {
    background: var(--shade);
  }

  #timer {
    font-size: 20px;
    font-weight: bold;
  }

  #info {
    font-size: 14px;
    margin-top: 6px;
    opacity: 0.7;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }

  td,
  th {
    border-right: 1px solid var(--shade);
    padding: 8px;
  }

  td:last-child,
  th:last-child {
    border-right: none;
  }

  th {
    border-bottom: 1px solid var(--shade);
  }

  td {
    text-align: right;
  }

  ul {
    margin: 0 0 24px;
    padding-left: 16px;
  }

  .card {
    background: var(--shade-light);
    border-radius: 4px;
    padding: 8px;
    font-size: 14px;
    margin: 0 0 8px;
    min-width: 96px;
  }

  .card h4 {
    margin: 0 0 4px;
    line-height: 1;
    font-size: 16px;
  }

  [v-cloak] {
    display: none;
  }
</style>

<main id="app" :class="{big: gameSize > 7}" v-cloak>
  <h1>Loopover</h1>
  <div style="display: flex; align-items: flex-end; height: 72px;">
    <div style="flex-grow: 1; margin-bottom: 16px;">
      <div id="timer">{{ formatTime(time) }}</div>
      <div id="info">
        <template v-if="isScrambled">
          The timer starts with the next move
        </template>
        <template v-else-if="gameStarted || moves > 0">
          {{ moves }} moves
        </template>
        <template v-else>
          Tap scramble to start a new game
        </template>
      </div>
    </div>
    <div style="margin: 0 0 12px; display: flex;">
      <button @click="reset" v-if="!isSolved">RESET</button>
      <button @click="scramble">SCRAMBLE</button>
    </div>
  </div>
  <canvas id="canvas" width="480" height="480"></canvas>
  <div style="margin-top: 24px; display: flex; flex-wrap: wrap; justify-content: center">
    <button v-for="item in gameSizes" :class="{active: item == gameSize}" @click="gameSize = item">{{ eventName(item) }}</button>
  </div>
  <hr>
  <button @click="useSpacing = !useSpacing">{{ useSpacing ? "REMOVE SPACE BETWEEN TILES" : "ADD SPACE BETWEEN TILES" }}</button>
  <button @click="useLetters = !useLetters">{{ useLetters ? "USE NUMBERS" : "USE LETTERS" }}</button>
  <button @click="dark = !dark">{{ dark ? "LIGHT THEME" : "DARK THEME" }}</button>
  <hr>
  <h3>Stats for {{ eventName(gameSize) }}</h3>
  <div style="display: flex; flex-wrap: wrap; margin: 0 -8px 8px;">
    <div style="flex-grow: 1; margin: 0 4px 8px;" class="card">
      <h4>Best time</h4>{{ formatTime(41294) }}
    </div>
    <div style="flex-grow: 1; margin: 0 4px 8px;" class="card">
      <h4>Worst time</h4>{{ formatTime(10242) }}
    </div>
    <div style="flex-grow: 1; margin: 0 4px 8px;" class="card">
      <h4>Total solves</h4>31
    </div>
  </div>
  <table>
    <tr>
      <th></th>
      <th>Best</th>
      <th>Current</th>
    </tr>
    <tr>
      <td>Ao3</td>
      <td>{{ formatTime(2412) }}</td>
      <td>{{ formatTime(3292) }}</td>
    </tr>
    <tr>
      <td>Ao5</td>
      <td>{{ formatTime(3124) }}</td>
      <td>{{ formatTime(4290) }}</td>
    </tr>
    <tr>
      <td>Ao12</td>
      <td>{{ formatTime(3412) }}</td>
      <td>{{ formatTime(4839) }}</td>
    </tr>
  </table>
  <button style="margin-top: 16px;">Reset stats for {{ eventName(gameSize) }} event</button>
  <hr>
  <p>
    Created by <a href="https://gitlab.com/janispritzkau"> Janis Pritzkau</a>.
    Remake of carykh's <a href="https://openprocessing.org/sketch/580366">loopover</a>.
  </p>
</main>

<script>(() => {
    const STORAGE_KEY = "loopover"

    const loadState = () => {
      try {
        return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}
      } catch (e) { return {} }
    }

    const saveState = state => {
      return localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
    }

    const checkIfSolved = state => {
      for (let [rowIndex, row] of state.entries()) {
        for (let [col, tile] of row.entries()) {
          if (tile != rowIndex * row.length + col) return false
        }
      }
      return true
    }

    const { highScores, ...storedState } = loadState()
    const gameSizes = [2, 3, 4, 5, 6, 7, 8, 9, 10]

    const app = new Vue({
      el: "#app",
      data: {
        dark: false,
        useLetters: true,
        useSpacing: false,
        isSolved: storedState.game ? checkIfSolved(storedState.game) : true,
        isScrambled: false,
        gameStarted: false,
        time: 0, moves: 0,
        gameSizes,
        gameSize: 5,
        game: null,
        highScores: new Map(highScores || gameSizes.map(gameSize => [gameSize, 0])),
        ...storedState
      },
      methods: {
        eventName: gameSize => `${gameSize}Ã—${gameSize}`,
        formatTime(ms, noPad = true) {
          const s = ms / 1000
          const min = s / 60 | 0, sec = s % 60 | 0, mil = ms % 1000
          return `${min}:${sec.toString().padStart(2, 0)}:${mil.toString().padStart(3, 0)}`
        },
        saveState() {
          const { useLetters, useSpacing, gameSize, dark, highScores, game } = this
          saveState({
            dark, useLetters, useSpacing, gameSize, game,
            highScores: [...highScores]
          })
        },
        updateTiles() {
          drawTilesCanvas()
          draw()
        },
        reset() {
          resetState()
          this.game = state
          this.isScrambled = false
          this.isSolved = true
          this.gameStarted = false
          this.solves = 0
          this.time = 0
          this.moves = 0
          this.saveState()
          draw()
        },
        async scramble() {
          this.gameStarted = false
          await scramble(cols * rows * 2 + 2)
          this.moves = 0
          this.time = 0
          this.isScrambled = true
          this.isSolved = false
          draw()
        },
        onSolved() {
          this.gameStarted = false
          this.isSolved = true
          clearInterval(this._timerInterval)
          this.time = Date.now() - this._startTime
          const highScore = this.highScores.get(this.gameSize)
          if (highScore == 0 || this.time < highScore) {
            this.highScores.set(this.gameSize, this.time)
          }
        },
        onMove(n) {
          this.isSolved = checkIfSolved(state)
          if (!this.gameStarted && this.isScrambled) {
            this.gameStarted = true
            this.isScrambled = false
            this._timerInterval = setInterval(() => {
              this.time = Date.now() - this._startTime
            }, 67)
            this._startTime = Date.now()
          }
          if (this.gameStarted) this.moves += n
          if (this.gameStarted && this.isSolved) this.onSolved()
          this.game = state
          this.saveState()
        }
      },
      watch: {
        gameStarted() {
          if (this.gameStarted == false) clearInterval(this._timerInterval)
        },
        dark: {
          immediate: true, handler(value) {
            document.documentElement.classList.toggle("dark", value)
            this.saveState()
          }
        },
        gameSize() {
          updateGameSize()
          this.reset()
          updateCanvasSize(canvas.getBoundingClientRect())
          this.saveState()
        },
        useLetters() {
          this.updateTiles()
          this.saveState()
        },
        useSpacing() {
          updateCanvasSize(canvas.getBoundingClientRect())
          this.saveState()
        }
      }
    })

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById("canvas")
    const ctx = canvas.getContext("2d")

    const tilesCanvas = document.createElement("canvas")
    const tilesCtx = tilesCanvas.getContext("2d")

    let dpr = devicePixelRatio
    let cols = 0, rows = 0, aspectRatio = 1
    let width = 0, height = 0
    let gap = 0
    let size = 0

    const MoveAxis = { row: 0, column: 1 }

    let moveAxis = null
    let touches = new Map
    let moveAmounts = new Map

    /** @type {number[][]} */
    let state = app.game

    const updateGameSize = () => {
      cols = app.gameSize, rows = cols
      aspectRatio = cols / rows
    }

    const updateGapSize = () => {
      gap = app.useSpacing ? Math.round((1 + 16 / app.gameSize) * dpr) : 0
    }

    const resetState = () => {
      state = new Array(rows).fill(null)
        .map((_, row) => new Array(cols).fill(null)
          .map((_, col) => row * cols + col))
    }

    const moveRow = (i, n) => {
      const row = state[i]
      state[i] = row.map((cell, i) => row[(i + cols * 2 - n) % cols])
    }

    const moveColumn = (i, n) => {
      const col = new Array(rows).fill(null).map((_, j) => state[j][i])
      for (let j = 0; j < rows; j++) state[j][i] = col[(j + rows * 2 - n) % rows]
    }

    async function scramble(moves = 50) {
      for (let i = 0; i < moves; i++) {
        if (Math.random() > 0.5) moveRow(Math.floor(Math.random() * rows), Math.floor(Math.random() * cols))
        else moveColumn(Math.floor(Math.random() * cols), Math.floor(Math.random() * rows))
        if (i % 10 == 0) await new Promise(res => setTimeout(res, 0))
        draw()
      }
      if (checkIfSolved(state)) await scramble(moves)
    }

    const updateCanvasSize = rect => {
      width = Math.round(rect.width * dpr)
      height = Math.round(width / aspectRatio)
      updateGapSize()
      size = Math.ceil((width - gap * 2) / cols)
      const tilesCanvasW = Math.ceil(size) * rows * cols
      const tilesCanvasH = Math.ceil(size)
      if (tilesCanvas.width != tilesCanvasW || tilesCanvas.height != tilesCanvasH) {
        tilesCanvas.width = tilesCanvasW, tilesCanvas.height = tilesCanvasH
      }
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width, canvas.height = height
      }
      drawTilesCanvas()
      draw()
    }

    const drawTile = (x, y, i) => ctx.drawImage(tilesCanvas,
      i * size, 0, size, size, gap > 0 ? x : x | 0, gap > 0 ? y : y | 0, size, size
    )

    const draw = () => {
      ctx.clearRect(0, 0, width, height)
      const moveDir = moveAxis == null ? MoveAxis.row : moveAxis
      for (let j = 0; j < (moveDir == MoveAxis.column ? cols : rows); j++) {
        let moveAmount = moveAxis != null ? moveAmounts.get(j) || 0 : 0
        for (let k = Math.floor(-moveAmount); k < (moveDir == MoveAxis.column ? rows : cols) - Math.floor(moveAmount); k++) {
          let [x, y] = [k, j]
          let px = k + moveAmount, py = j
          if (moveDir == MoveAxis.column) {
            [px, py] = [py, px];[x, y] = [y, x];
          }
          drawTile(px * (width - gap * 2) / cols + gap, py * (height - gap * 2) / rows + gap, state[(y + rows * 2) % rows][(x + cols * 2) % cols])
        }
      }
    }

    const drawTilesCanvas = () => {
      tilesCtx.clearRect(0, 0, size * cols * rows, size)
      const radius = Math.min(Math.max(6 * dpr, gap * 2) | 0, 12 * dpr)
      const padd = gap == 0 ? 0 : radius / 2 + gap;
      tilesCtx.font = `${size * 0.4}px monospace`
      tilesCtx.textBaseline = "middle", tilesCtx.textAlign = "center"
      tilesCtx.lineJoin = "round", tilesCtx.lineWidth = radius
      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const i = row * cols + col, xOffset = Math.ceil(size) * i
          const text = app.useLetters && cols * rows <= 26 ? String.fromCharCode(i + 65) : (i + 1).toString()
          const cx = (col + .4) / (cols - .6), cy = (row + .4) / (rows - .6)
          tilesCtx.fillStyle = `rgb(${[cx * 230 + 20, cy * 105 + (1 - cx) * 25 + 60, (1 - cx) * 200].join()})`
          tilesCtx.strokeStyle = tilesCtx.fillStyle
          tilesCtx.fillRect(xOffset + padd, padd, size - padd * 2, size - padd * 2)
          if (padd != 0) tilesCtx.strokeRect(xOffset + padd, padd, size - padd * 2, size - padd * 2)
          tilesCtx.fillStyle = "#fff"
          tilesCtx.fillText(text, xOffset + size / 2, size / 2 + 2)
        }
      }
    }

    const onMoveStart = touch => {
      touch.startCol = Math.floor(((touch.startX - rect.left) * dpr - gap) / size)
      touch.startRow = Math.floor(((touch.startY - rect.top) * dpr - gap) / size)
    }

    const easeInOutQuad = t => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t

    const animateMove = (dir, i, n) => {
      if (n % (dir == MoveAxis.column ? cols : rows) == 0) return
      moveAmounts.clear()
      moveAxis = dir
      moveAmounts.set(i, -n)
      const start = Date.now()
      const frame = () => {
        if (!moveAmounts.has(i)) return
        const v = (Date.now() - start) / 100
        moveAmounts.set(i, -n + n * easeInOutQuad(v))
        if (v < 1) requestAnimationFrame(frame)
        else moveAmounts.delete(i)
        draw()
      }
      frame()
    }

    const onMove = touch => {
      touch.col = Math.floor(((touch.x - rect.left) * dpr - gap) / size)
      touch.row = Math.floor(((touch.y - rect.top) * dpr - gap) / size)
      const moveX = touch.row - touch.startRow
      const moveY = touch.col - touch.startCol
      const colI = (touch.startCol + cols * 512) % cols
      moveColumn(colI, moveX)
      animateMove(MoveAxis.column, colI, moveX)
      touch.startRow = touch.row
      const rowI = (touch.startRow + rows * 512) % rows
      moveRow(rowI, moveY)
      animateMove(MoveAxis.row, rowI, moveY)
      touch.startCol = touch.col
      const moves = Math.abs(moveX) + Math.abs(moveY)
      if (moves) app.onMove(moves)
      draw()
    }

    canvas.addEventListener("mousedown", e => {
      e.preventDefault()
      rect = canvas.getBoundingClientRect()
      touches.set(-1, { startX: e.clientX, startY: e.clientY, x: 0, y: 0 })
      onMoveStart(touches.get(-1))
    })
    addEventListener("mousemove", e => {
      if (!touches.has(-1)) return
      const touch = touches.get(-1)
      touch.x = e.clientX, touch.y = e.clientY
      onMove(touch)
    })
    addEventListener("mouseup", e => touches.delete(-1))

    canvas.addEventListener("touchstart", e => {
      e.preventDefault()
      rect = canvas.getBoundingClientRect()
      for (let item of e.changedTouches) {
        touches.set(item.identifier, {
          startX: item.clientX, startY: item.clientY, x: 0, y: 0
        })
        onMoveStart(touches.get(item.identifier))
      }
    })
    addEventListener("touchmove", e => {
      for (let item of e.changedTouches) {
        if (!touches.has(item.identifier)) continue
        const touch = touches.get(item.identifier)
        touch.x = item.clientX, touch.y = item.clientY
        onMove(touch)
      }
    })
    addEventListener("touchend", e => {
      for (let item of e.changedTouches) touches.delete(item.identifier)
    })

    const debounce = (fn, time) => {
      let timeout
      return function () {
        const functionCall = () => fn.apply(this, arguments)
        clearTimeout(timeout)
        timeout = setTimeout(functionCall, time)
      }
    }

    updateGameSize()
    if (!state) resetState()

    const _updateSize = debounce(updateCanvasSize, 25)
    let lastRect
    new ResizeObserver(l => l.forEach(({ contentRect: rect }) => {
      if (lastRect && lastRect.width == rect.width) return
      _updateSize(rect); lastRect = rect
    }))
      .observe(canvas)
  })()</script>