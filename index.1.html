<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Loopover</title>

<style>

body {
    font-family: "Roboto";
    background: rgb(245, 242, 236);
    margin: 0;
    color: rgba(30, 10, 5, 0.7);
}
main {
    max-width: 480px;
    margin: 32px auto;
    padding: 0 24px;
}
h1 {
    font-size: 36px;
    margin: 32px 0 16px;
}

.canvas-container {
    background: rgba(30, 10, 5, 0.3);
    border-radius: 4px;
    padding: 6px;
    margin-bottom: 16px;
}
#canvas {
    display: block;
    width: 100%;
}

</style>

<main>
    <h1>Loopover</h1>
    <div class="canvas-container">
        <canvas id="canvas"></canvas>
    </div>
</main>

<script>(() => {

const cols = 5, rows = 5
const aspectRatio = cols / rows
const dpr = 2
// const dpr = devicePixelRatio || 1

/** @type {HTMLCanvasElement} */
const canvas = document.getElementById("canvas")
const ctx = canvas.getContext("2d")

const tilesCanvas = document.createElement("canvas")
const tilesCtx = tilesCanvas.getContext("2d")
document.querySelector("main").appendChild(tilesCanvas)

let width = 0, height = 0, size = 0
/** @type {number[][]} */
let state = null

const resetState = () => {
    state = new Array(rows).fill(null).map((_, row) => new Array(cols).fill(null).map(
        (_, col) => row * cols + col
    ))
}

const updateCanvasSize = rect => {
    width = Math.round(rect.width)
    height = Math.round(width / aspectRatio)
    size = width / cols

    canvas.width = width * dpr, canvas.height = height * dpr
    tilesCanvas.width = size * rows * cols * dpr, tilesCanvas.height = size * dpr
    tilesCanvas.style.height = size + "px"
    tilesCtx.scale(dpr, dpr)
    ctx.scale(dpr, dpr)
    drawTilesCanvas()
    draw()
}


const drawTilesCanvas = () => {
    tilesCtx.textBaseline = "middle"
    tilesCtx.textAlign = "center"
    tilesCtx.font = `${width / cols * 0.4}px monospace`

    const radius = 4;
    tilesCtx.lineJoin = "round"
    tilesCtx.lineWidth = radius

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const i = row * cols + col
            const cx = (col + .25) / (cols - .75), cy = (row + .25) / (rows - .75)
            tilesCtx.fillStyle = `rgb(${[cx * 240, cy * 130 + (1 - cx) * 20 + 25, (1 - cx) * 180].join()})`
            tilesCtx.strokeStyle = tilesCtx.fillStyle
            const marg = radius / 2 + 6
            tilesCtx.fillRect(i*size + marg, marg, size-marg*2, size-marg*2)
            tilesCtx.strokeRect(i*size+marg, marg, size-marg*2, size-marg*2)
            tilesCtx.fillStyle = "#fff"
            tilesCtx.fillText(i+1, size*i+size/2, size/2+2)
        }
    }
}

const drawTile = (x, y, i) => ctx.drawImage(tilesCanvas,
    Math.ceil(i*size*dpr), 0, size*dpr|0, size*dpr|0, x, y, Math.ceil(size), Math.ceil(size)
)

const draw = () => {
    ctx.clearRect(0, 0, width, height)

    const moveDir = "row"
    for (let j = 0; j < (moveDir == "col" ? cols : rows); j++) {
        // let moveAmount = moveState.direction != null ? moveState.moving.get(j) || 0 : 0
        // let isMoving = moveAmount != null
        let moveAmount = 0

        for (let k = Math.floor(-moveAmount); k < (moveDir == "col" ? rows : cols) - Math.floor(moveAmount); k++) {
            let [x, y] = [k, j]
            let px = k * size + moveAmount * size
            let py = j * size
            if (moveDir == "col") {
                [px, py] = [py, px];
                [x, y] = [y, x];
            }
            drawTile(px, py, state[(y + rows*2) % rows][(x + cols*2) % cols])
        }
    }
}

resetState()

console.log(state)

new ResizeObserver(l => l.forEach(x => updateCanvasSize(x.contentRect)))
.observe(canvas)

})()</script>